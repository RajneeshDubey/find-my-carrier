import { objectWithoutProperties as _objectWithoutProperties, extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import { useRef, useState, useEffect, useCallback, createElement } from 'react';
import classNames from 'classnames';
import { Snack } from './Snack.js';
import { SnackAction } from './SnackAction.js';
import { SnackbarContext } from './SnackbarContext.js';
import { useFocusControl } from '../utility/useFocusControl.js';
import { useReturnFocus } from '../utility/useReturnFocus.js';
import style from './Snackbar.module.scss.js';

var SnackbarProvider = ({
  children
}) => {
  var initialActionRef = useRef(null);
  var [activeSnack, setActiveSnack] = useState();
  var [actionRef, setActionRef] = useState(initialActionRef);
  var [isRemoving, setRemoving] = useState(false); // @see {@link https://reactjs.org/docs/context.html#caveats}

  var contextValue = useRef({
    addSnack: setActiveSnack
  }); // do not return focus if no action button is present

  var disableReturnFocus = !actionRef.current;
  useFocusControl(actionRef, [actionRef, activeSnack]);
  useReturnFocus([activeSnack, actionRef], disableReturnFocus);
  useEffect(() => {
    if (!activeSnack) {
      return () => undefined;
    }

    var {
      message,
      actionButton,
      autoHideDuration = null
    } = activeSnack;

    if (actionButton !== null && actionButton !== void 0 && actionButton.ref && actionButton.ref !== actionRef) {
      setActionRef(actionButton === null || actionButton === void 0 ? void 0 : actionButton.ref);
    }

    var defaultDuration = message.length > 120 ? 3500 + (message.length - 120) * 60 : 3500;
    var duration = autoHideDuration ? autoHideDuration : defaultDuration;
    var timeoutID = setTimeout(() => {
      setRemoving(true);
    }, duration);
    return () => {
      clearTimeout(timeoutID);
    };
  }, [activeSnack]);
  var onAnimationEnd = useCallback(() => {
    /* istanbul ignore if */
    if (!isRemoving) {
      return;
    }

    setActiveSnack(undefined);
    setRemoving(false);
  }, [isRemoving]);
  var onAnimationStart = useCallback(() => {
    /* istanbul ignore if */
    if (!isRemoving || typeof (activeSnack === null || activeSnack === void 0 ? void 0 : activeSnack.onClose) !== "function") {
      return;
    }

    activeSnack.onClose();
  }, [isRemoving, activeSnack]);
  var snack;

  if (activeSnack) {
    var {
      actionButton,
      message,
      onClose,
      className,
      autoHideDuration
    } = activeSnack,
        rest = _objectWithoutProperties(activeSnack, ["actionButton", "message", "onClose", "className", "autoHideDuration"]);

    var action = actionButton && /*#__PURE__*/createElement(SnackAction, {
      ref: actionRef,
      onClick: () => {
        actionButton.onClick();
        setRemoving(true);
      }
    }, actionButton.message);
    snack = /*#__PURE__*/createElement(Snack, _extends({
      action: action,
      className: classNames(isRemoving ? style.fadeOut : style.fadeIn, className),
      onAnimationEnd: onAnimationEnd,
      onAnimationStart: onAnimationStart,
      onClose: () => setRemoving(true)
    }, rest), message);
  }

  return /*#__PURE__*/createElement(SnackbarContext.Provider, {
    value: contextValue.current
  }, children, /*#__PURE__*/createElement("div", {
    className: style.root,
    "aria-live": "assertive"
  }, snack));
};

export { SnackbarProvider };
