import { objectWithoutProperties as _objectWithoutProperties, objectSpread2 as _objectSpread2, extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import { useRef, useCallback, useEffect, createElement } from 'react';
import classNames from 'classnames';
import { applyCommonProps } from '../utility/commonProps.js';
import { BasePopover } from './BasePopover.js';
import { useOnClickOutside } from '../utility/useOnClickOutside.js';
import { useOnKeyDown } from '../utility/useOnKeyDown.js';
import { FocusGuard } from '../FocusGuard/FocusGuard.js';
import { usePortal } from '../utility/usePortal.js';
import style from './PopoverPortal.module.scss.js';
import { Layer } from '../Layer/Layer.js';
import { usePopper } from 'react-popper';
import { FocusTrap } from '../FocusTrap/FocusTrap.js';
import { useForceUpdate } from '../utility/useForceUpdate.js';

var PopoverPortal = props => {
  var _applyCommonProps = applyCommonProps(props, PopoverPortal),
      {
    basePopoverProps = {},
    className,
    content,
    hasNubbin = false,
    onClose,
    popoverContainerRef,
    position = "bottom",
    triggerRef,
    isFixed = false,
    focusLock = false,
    margin = hasNubbin ? 12 : 4,
    skid = 0,
    overrides = {},
    popperOptions = {},
    autoFocus = true,
    disableCloseOnClickOutside = false,
    disableCloseOnEsc = false,
    disablePopoverFlip = false,
    mountNodeRef,
    disablePortal = false,
    onMouseEnter = () => {},
    onMouseLeave = () => {}
  } = _applyCommonProps,
      rest = _objectWithoutProperties(_applyCommonProps, ["basePopoverProps", "className", "content", "hasNubbin", "onClose", "popoverContainerRef", "position", "triggerRef", "isFixed", "focusLock", "margin", "skid", "overrides", "popperOptions", "autoFocus", "disableCloseOnClickOutside", "disableCloseOnEsc", "disablePopoverFlip", "mountNodeRef", "disablePortal", "onMouseEnter", "onMouseLeave"]);

  var popoverRef = useRef(null);
  var popoverMountRef = !disablePortal ? mountNodeRef || usePortal({
    a11yHidden: false
  }) : useRef();
  var arrowRef = useRef(null);
  var anchorRef = triggerRef.current ? triggerRef :
  /* istanbul ignore next */
  popoverContainerRef; // Prevents overflow

  var customTetherOffset = useCallback(({
    popper,
    placement
  }) => {
    if (String(placement).includes("right") || String(placement).includes("left")) {
      return popper.height;
    }

    return 0;
  }, []); // Offset modifier to modifiy popper skidding flip usecase

  var customPopperOffset = useCallback(({
    placement
  }) => {
    var [, align] = placement.split("-");

    if (align === "start") {
      return [-Math.abs(Number(skid)), margin];
    } else if (align === "end") {
      return [Math.abs(Number(skid)), margin];
    } else {
      return [skid, margin];
    }
  }, [skid, margin]);
  var defaultPopperOptions = {
    modifiers: [{
      name: "offset",
      options: {
        offset: customPopperOffset
      }
    }, {
      name: "arrow",
      options: {
        element: arrowRef.current
      }
    }, {
      name: "preventOverflow",
      options: {
        tetherOffset: customTetherOffset
      }
    }, {
      name: "flip",
      enabled: !disablePopoverFlip
    }]
  };
  var {
    styles,
    attributes,
    state: popperState,
    update: popoverUpdate
  } = usePopper(anchorRef.current, popoverRef.current, _objectSpread2(_objectSpread2({
    strategy: isFixed ? "fixed" : "absolute",
    placement: position
  }, popperOptions), {}, {
    modifiers: [...defaultPopperOptions.modifiers, ...(popperOptions.modifiers || [])]
  }));
  var forceUpdate = useForceUpdate();

  var isPopperPositioned = () => !!popperState;

  var onCloseWithFocusReturn = event => {
    (anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.current).focus();
    onClose(event);
  };

  var onDocumentClick = evt => {
    if (disableCloseOnClickOutside) {
      return;
    }

    onClose && onClose(evt);
  };

  var onEsc = event => {
    if (disableCloseOnEsc) {
      return;
    }

    onCloseWithFocusReturn(event);
  }; // TODO: Find better way to handle click outside, possibly event delegation


  useOnClickOutside([anchorRef, popoverRef], onDocumentClick, {
    disablePreventDefault: true
  });
  useOnKeyDown(["Esc", "Escape"], onEsc);
  /*
   * Forcing popover/component to re-render is updating postion of popper
   * https://popper.js.org/docs/v2/modifiers/event-listeners/
   */

  useEffect(() => {
    forceUpdate();
    popoverUpdate && popoverUpdate();
  }, [content, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.current, popoverMountRef === null || popoverMountRef === void 0 ? void 0 : popoverMountRef.current, hasNubbin]);
  useEffect(() => {
    /* istanbul ignore else */
    if (!isPopperPositioned()) {
      var _popoverRef$current;

      forceUpdate();
      (_popoverRef$current = popoverRef.current) === null || _popoverRef$current === void 0 ? void 0 : _popoverRef$current.style.removeProperty("visibility");
    }
  }, []);
  var close = useCallback(evt => {
    onClose && onClose(evt);
  }, [onClose]);

  var renderContentWithFocusLock = renderContent => {
    if (focusLock) {
      /*
       ** Using react-focus-lock to trap the focus inside popover
       ** popover wont close on tab be in loop
       */
      return /*#__PURE__*/createElement(FocusTrap, {
        hasFocusReturn: false,
        autoFocus: isPopperPositioned() && autoFocus // autofocus after popper positioned
        ,
        noFocusGuards: false
      }, renderContent);
    } else {
      /*
       ** Popover closes when no more focusable elements on tab
       */
      return /*#__PURE__*/createElement(FocusGuard, {
        autoFocus: autoFocus,
        onGuard: onCloseWithFocusReturn
      }, renderContent);
    }
  };

  var getArrowClassFromPositon = placement => {
    var [basePosition] = (placement ||
    /* istanbul ignore next */
    "").split("-");
    return style[basePosition];
  };

  var renderInnerContent = () => {
    return /*#__PURE__*/createElement(BasePopover, _extends({}, basePopoverProps, {
      className: classNames(style.popperBase, basePopoverProps === null || basePopoverProps === void 0 ? void 0 : basePopoverProps.className),
      contentClassName: classNames(overrides.content)
    }), typeof content === "function" ? content({
      close
    }) : content);
  };

  var renderArrowContent = () => {
    var _attributes$popper;

    return /*#__PURE__*/createElement("div", {
      ref: arrowRef,
      style: styles.arrow,
      className: classNames(isPopperPositioned() ? style.show : null, isPopperPositioned() && getArrowClassFromPositon((_attributes$popper = attributes.popper) === null || _attributes$popper === void 0 ? void 0 : _attributes$popper["data-popper-placement"]), style.arrow, overrides.arrow)
    });
  };

  return /*#__PURE__*/createElement(Layer, {
    disablePortal: disablePortal,
    mountNode: popoverMountRef === null || popoverMountRef === void 0 ? void 0 : popoverMountRef.current
  }, /*#__PURE__*/createElement("div", _extends({}, rest, {
    style: _objectSpread2({
      visibility: "hidden"
    }, styles.popper)
  }, attributes.popper, {
    ref: popoverRef,
    className: classNames(style.popover, overrides.base, className),
    onMouseLeave: onMouseLeave,
    onMouseEnter: onMouseEnter
  }), hasNubbin && renderArrowContent(), renderContentWithFocusLock(renderInnerContent())));
};

export { PopoverPortal };
