import { objectWithoutProperties as _objectWithoutProperties, extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import { useRef, Children, useState, useEffect, createElement, Fragment, cloneElement } from 'react';
import classNames from 'classnames';
import { PopoverPortal } from './PopoverPortal.js';
import style from './StatefullPopover.module.scss.js';

var StatefullPopover = props => {
  var {
    children,
    hideDelay = 200,
    showDelay = 0,
    onMouseEnter = () => {},
    onMouseLeave = () => {},
    trigger = "click",
    onClose = () => {},
    onOpen = () => {},
    isOpen,
    inititalState,
    containerClassName = ""
  } = props,
      rest = _objectWithoutProperties(props, ["children", "hideDelay", "showDelay", "onMouseEnter", "onMouseLeave", "trigger", "onClose", "onOpen", "isOpen", "inititalState", "containerClassName"]);

  var popoverContainerRef = useRef(null);
  var triggerRef = useRef();
  var child = Children.only(children);
  var isControlled = isOpen !== undefined;
  var [statefullOpen, setStatefefullOpen] = useState(inititalState);
  var hideTimer = useRef();
  var showTimer = useRef();

  var handleClose = evt => {
    statefullOpen && onClose(evt);

    if (!isControlled) {
      setStatefefullOpen(false);
    }
  };

  var handleOpen = evt => {
    !statefullOpen && onOpen(evt);

    if (!isControlled) {
      setStatefefullOpen(true);
    }
  };

  var isPopoverHover = () => {
    return trigger === "hover";
  };

  var clearTimers = () => {
    [hideTimer.current, showTimer.current].forEach(timer => {
      if (timer) {
        clearTimeout(timer);
      }
    });
  };

  var handleAnchorMouseEnter = evt => {
    if (hideTimer.current) {
      clearTimeout(hideTimer.current);
    }

    showTimer.current = setTimeout(() => {
      handleOpen(evt);
    }, showDelay);
  };

  var handlePopoverMouseEnter = () => {
    if (hideTimer.current) {
      clearTimeout(hideTimer.current);
    }
  };

  var handleAnchorMouseLeave = evt => {
    /* istanbul ignore else */
    if (showTimer.current) {
      clearTimeout(showTimer.current);
    }

    hideTimer.current = setTimeout(() => {
      handleClose(evt);
    }, hideDelay);
  };

  var handlePopoverMouseLeave = evt => {
    /* istanbul ignore else */
    if (showTimer.current) {
      clearTimeout(showTimer.current);
    }

    hideTimer.current = setTimeout(() => {
      handleClose(evt);
    }, hideDelay);
  };

  var handleAnchorClick = evt => {
    if (statefullOpen) {
      handleClose(evt);
    } else {
      handleOpen(evt);
    }
  };

  var getContainerEventHandlers = () => {
    if (isPopoverHover()) {
      return {
        onMouseEnter: evt => {
          handleAnchorMouseEnter(evt);
        },
        onMouseLeave: evt => {
          handleAnchorMouseLeave(evt);
        }
      };
    } else {
      return {
        onClick: evt => {
          handleAnchorClick(evt);
        }
      };
    }
  };

  useEffect(() => {
    return () => {
      clearTimers();
    };
  }, []);
  useEffect(() => {
    if (!isControlled) {
      return;
    }

    setStatefefullOpen(isOpen);
  }, [isOpen]);
  return /*#__PURE__*/createElement(Fragment, null, /*#__PURE__*/createElement("span", _extends({
    className: classNames(style.popoverContainer, containerClassName),
    ref: popoverContainerRef
  }, getContainerEventHandlers()), /*#__PURE__*/cloneElement(child, {
    "aria-expanded": statefullOpen,
    "aria-haspopup": true,
    ref: node => {
      var {
        ref
      } = child; // @see {@link https://github.com/facebook/react/issues/8873#issuecomment-489579878}

      if (typeof ref === "function") {
        ref(node);
      } else if (ref != null) {
        ref.current = node;
      }

      triggerRef.current = node;
    }
  })), statefullOpen && /*#__PURE__*/createElement(PopoverPortal, _extends({}, rest, {
    popoverContainerRef: popoverContainerRef,
    triggerRef: triggerRef,
    onMouseEnter: evt => {
      /* istanbul ignore else */
      if (isPopoverHover()) {
        handlePopoverMouseEnter();
      }

      onMouseEnter(evt);
    },
    onMouseLeave: evt => {
      /* istanbul ignore else */
      if (isPopoverHover()) {
        handlePopoverMouseLeave(evt);
      }

      onMouseLeave(evt);
    },
    onClose: evt => {
      handleClose(evt);
    }
  })));
};

export { StatefullPopover };
