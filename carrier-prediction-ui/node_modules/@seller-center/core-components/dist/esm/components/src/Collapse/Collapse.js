import { objectWithoutProperties as _objectWithoutProperties, extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import { useState, useRef, useEffect, createElement } from 'react';
import classNames from 'classnames';
import { throttle } from '../utility/throttle.js';
import style from './Collapse.module.scss.js';

var Collapse = _ref => {
  var {
    children,
    className,
    isOpen = false,
    minHeight = 0
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["children", "className", "isOpen", "minHeight"]);

  // const { children, className, isOpen = false, minHeight = 0, ...rest } = props;
  var [maxHeight, setMaxHeight] = useState();
  var ref = useRef(null);
  var contentRef = useRef(null);
  var isHidden = !isOpen && minHeight === 0; // NOTE: Auto prevents transitions on open content.

  var contentHeight = maxHeight || "auto";

  if (!isOpen) {
    contentHeight = minHeight;
  }
  /**
   * NOTE: This hook manages the case where the child content size changes while the
   * component is open / visible
   */


  useEffect(() => {
    var {
      current
    } = contentRef; // istanbul ignore next

    var observer = new ResizeObserver(entries => {
      setMaxHeight(entries[0].target.scrollHeight);
    });
    /* istanbul ignore else: branch coverage fix */

    if (current) {
      observer.observe(current);
    }

    return () => {
      /* istanbul ignore else: branch coverage fix */
      if (current) {
        observer.unobserve(current);
      }
    };
  }, [contentRef]);
  /**
   * NOTE: This hook manages happy path height recalculations. Hook dependencies are finiky so please
   * be careful of that. Ensure that this component gets properly rendered in all conditionsâ€”including `Modal`.
   */

  useEffect(() => {
    var {
      current
    } = ref;
    setMaxHeight(current === null || current === void 0 ? void 0 : current.scrollHeight);
  }, [maxHeight]);
  /**
   * Note: This hook manages accessibility and visibility. Edge case where bottom
   * margin is not calculated in scrollHeight. Once transition ends this will
   * ensure height is updated.
   */

  useEffect(() => {
    var {
      current
    } = ref;
    /* istanbul ignore else: branch coverage fix */

    if (current) {
      current.style.visibility = isHidden ? "hidden" : "";
    }
    /* istanbul ignore next */


    var onTransitionEnd = () => {
      // NOTE: Once content is collapsed, we need to hide it from screen readers.
      if (current && isHidden) {
        current.style.visibility = "hidden";
        return;
      }
      /* istanbul ignore else: branch coverage fix */


      if (maxHeight === (current === null || current === void 0 ? void 0 : current.scrollHeight)) {
        return;
      }
      /* istanbul ignore next: ignoring edge case */


      setMaxHeight(current === null || current === void 0 ? void 0 : current.scrollHeight);
    };

    current === null || current === void 0 ? void 0 : current.addEventListener("transitionend", onTransitionEnd);
    return () => {
      current === null || current === void 0 ? void 0 : current.removeEventListener("transitionend", onTransitionEnd);
    };
  }, [isHidden, maxHeight]);
  /**
   * NOTE: This hook manages changes to the component height when the browser resizes.
   */

  useEffect(() => {
    var onResize = throttle(() => {
      var {
        current
      } = ref; // Set content height on page resize.

      setMaxHeight(current === null || current === void 0 ? void 0 : current.scrollHeight);
    }, 33.33);
    window.addEventListener("resize", onResize);
    return () => {
      window.removeEventListener("resize", onResize);
    };
  }, []);
  return /*#__PURE__*/createElement("div", _extends({
    "aria-hidden": isHidden,
    className: classNames(style.collapsible, isHidden && style.hidden, className),
    ref: ref // eslint-disable-next-line react/forbid-dom-props
    ,
    style: {
      maxHeight: contentHeight
    }
  }, rest), /*#__PURE__*/createElement("div", {
    ref: contentRef
  }, children));
};

export { Collapse };
